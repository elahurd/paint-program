
import java.awt.geom.Point2D;
import java.util.ArrayList;
import java.util.regex.Pattern;


public class SigerRecognizer {

    public enum PatternIndex {
        RED, GREEN, BLUE, BLACK, YELLOW, ORANGE, CLEAR, NONE
    } 

    private String[] redArray = {"UPS", "RIGHTS", "DOWNS", "LEFTS", "DOWNS", "RIGHTS"};
    private String[] greenArray = {"LEFTS", "DOWNS", "RIGHTS", "UPS", "LEFTS"};
    private String[] blueArray = {"UPS", "RIGHTS", "DOWNS", "LEFTS", "DOWNS", "RIGHTS", "DOWNS", "LEFTS"};
    private String[] blackArray = {"DOWNS", "RIGHTS"};
    private String[] yellowArray = {"RIGHTS_AND_DOWNS", "RIGHTS_AND_UPS"};
    private String[] orangeArray = {"LEFTS", "UPS", "RIGHTS", "DOWNS", "LEFTS"};
    private String[] clearArray = {"LEFTS", "DOWNS", "RIGHTS"};
    

    private Pattern[] patterns = { 
        Pattern.compile(buildPatternString(redArray)),
        Pattern.compile(buildPatternString(greenArray)),
        Pattern.compile(buildPatternString(blueArray)), 
        Pattern.compile(buildPatternString(blackArray)), 
        Pattern.compile(buildPatternString(yellowArray)), 
        Pattern.compile(buildPatternString(orangeArray)),
        Pattern.compile(buildPatternString(clearArray))
    };
    
    private String buildPatternString(String[] vector) {
        StringBuffer buffer = new StringBuffer();
        buffer.append("^");
        buffer.append(".{0,2}+");
        for (int i = 0; i < vector.length; i++) {
            switch (vector[i]) {
                case "RIGHT": buffer.append("R+"); break;
                case "UP": buffer.append("U+"); break;
                case "LEFT": buffer.append("L+"); break;
                case "DOWN": buffer.append("D+"); break;
                case "RIGHT_UP": buffer.append("W+"); break;
                case "LEFT_UP": buffer.append("X+"); break;
                case "LEFT_DOWN": buffer.append("Y+"); break;
                case "RIGHT_DOWN": buffer.append("Z+"); break;
                case "RIGHTS": buffer.append("[ZRW]+"); break;
                case "UPS": buffer.append("[UWX]+"); break;
                case "LEFTS": buffer.append("[XLY]+"); break;
                case "DOWNS": buffer.append("[YDZ]+"); break;
                case "RIGHTS_AND_DOWNS": buffer.append("[RDZ]+"); break;
                case "LEFTS_AND_DOWNS": buffer.append("[LYD]+"); break;
                case "RIGHTS_AND_UPS": buffer.append("[UWR]+"); break;
                case "LEFTS_AND_UPS": buffer.append("[LXU]+"); break;
                default:
                    break;
            }
        }
        
        buffer.append(".{0,2}+");
        buffer.append("$");
        return buffer.toString();
    }

    /**
     * This compares the pattern string generated by the user gesture to a list of predefined
     * patterns.
     * 
     * @param patternString The string to be matched against predefined patterns
     * @return an index to match to a gesture
     */
    public PatternIndex matchToTemplates(String patternString) {
        for (int i = 0; i < patterns.length; i++) {
            if (patterns[i].matcher(patternString).find()) {
                return PatternIndex.values()[i];
            } 
        }
        return PatternIndex.values()[patterns.length]; //returns NONE enum value for no match
    }

    /**
     * This builds a pattern string based on the direction vectors between each point
     * of the user's gesture.
     * 
     * @param stroke The stroke generated by the user's gesture
     * @return a pattern string to be used in comparison with a list of predefined gestures
     */
    public String buildDirectionVector(ArrayList<Point2D> stroke) {

        StringBuffer directionBuffer = new StringBuffer();

        for (int i = 1; i < stroke.size(); i++) {
            double x1 = stroke.get(i-1).getX();
            double x2 = stroke.get(i).getX();
            double y1 = stroke.get(i-1).getY();
            double y2 = stroke.get(i).getY();

            if (x1 - x2 < 0 && y1 - y2 > 0) {
                directionBuffer.append("W");
            } else if (x1 - x2 < 0 && y1 - y2 == 0) {
                directionBuffer.append("R");
            } else if (x1 - x2 < 0 && y1 - y2 < 0) {
                directionBuffer.append("Z");
            } else if (x1 - x2 == 0 && y1 - y2 < 0) {
                directionBuffer.append("D");
            } else if (x1 - x2 > 0 && y1 - y2 < 0) {
                directionBuffer.append("Y");
            } else if (x1 - x2 > 0 && y1 - y2 == 0) {
                directionBuffer.append("L");
            } else if (x1 - x2 > 0 && y1 - y2 > 0) {
                directionBuffer.append("X");
            } else if (x1 - x2 == 0 && y1 - y2 > 0) {
                directionBuffer.append("U");
            }
        }

        return directionBuffer.toString();
    }

    
}
